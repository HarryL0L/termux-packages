diff --git a/src/kcrash.cpp b/src/kcrash.cpp
index cf10afe..d9ac05e 100644
--- a/src/kcrash.cpp
+++ b/src/kcrash.cpp
@@ -185,15 +185,18 @@ static bool shouldWriteMetadataToDisk()
 
 void KCrash::initialize()
 {
+    printf("BEES1\n");
     if (s_launchDrKonqi == 0) { // disabled by the program itself
         return;
     }
+    printf("BEES2\n");
 
     bool enableDrKonqi = !qEnvironmentVariableIsSet("KDE_DEBUG");
     if (qEnvironmentVariableIsSet("KCRASH_AUTO_RESTARTED") || qEnvironmentVariableIntValue("RUNNING_UNDER_RR") == 1
         || qEnvironmentVariableIntValue("KCRASH_DUMP_ONLY") == 1) {
         enableDrKonqi = false;
     }
+    printf("BEES3\n");
 
     const QStringList args = QCoreApplication::arguments();
     // Default to core dumping whenever a process is set. When not or when explicitly opting into just in time debugging
@@ -202,21 +205,27 @@ void KCrash::initialize()
     //   the signal handler's closed FDs. That is primarily why we do not like JIT debugging.
     if (enableDrKonqi && (!s_coreConfig.isProcess() || qEnvironmentVariableIntValue("KCRASH_JIT_DRKONQI") == 1)) {
         KCrash::setDrKonqiEnabled(true);
+        printf("BEES4\n");
     } else {
+        printf("BEES5\n");
         // Don't qDebug here, it loads qtlogging.ini very early which prevents unittests from doing QStandardPaths::setTestModeEnabled(true) in initTestCase()
     }
 
     s_qtVersion.reset(qstrdup(qVersion()));
+    printf("BEES6\n");
 
     if (QCoreApplication::instance()) {
         const QString path = QCoreApplication::applicationFilePath();
         s_appFilePath.reset(qstrdup(qPrintable(path))); // This intentionally cannot be changed by the application!
         KCrash::setApplicationFilePath(path);
+        printf("BEES7\n");
     } else {
         qWarning() << "This process needs a QCoreApplication instance in order to use KCrash";
+        printf("BEES8\n");
     }
 
     if (shouldWriteMetadataToDisk()) {
+        printf("BEES9\n");
         // We do not actively clean up metadata via KCrash but some other service. This potentially means we litter
         // a lot -> put the metadata in a subdir.
         // This data is consumed by DrKonqi in combination with coredumpd metadata.
@@ -227,7 +236,9 @@ void KCrash::initialize()
             const auto pid = QString::number(QCoreApplication::applicationPid());
             s_metadataPath = QFile::encodeName(metadataDir + //
                                                QStringLiteral("/%1.%2.%3.ini").arg(exe, bootId, pid));
+            printf("BEES10\n");
         }
+        printf("BEES11\n");
         if (!s_crashHandler) {
             // Always enable the default handler. We cannot create the metadata ahead of time since we do not know
             // when the application metadata is "complete".
@@ -237,6 +248,7 @@ void KCrash::initialize()
             //    faulting thread; all other threads continue running!). therefore it'd be greatly preferred if we
             //    were able to write the metadata during initial app setup instead of when a crash occurs
             setCrashHandler(defaultCrashHandler);
+            printf("BEES12\n");
         }
     } // empty s_metadataPath disables writing
 }
@@ -433,35 +445,47 @@ void KCrash::defaultCrashHandler(int sig)
     static int crashRecursionCounter = 0;
     crashRecursionCounter++; // Nothing before this, please !
     s_originalSignal = sig;
+    printf("BEES13\n");
 
 #if !defined(Q_OS_WIN)
     signal(SIGALRM, SIG_DFL);
     alarm(3); // Kill me... (in case we deadlock in malloc)
 #endif
+    printf("BEES14\n");
 
     if (crashRecursionCounter < 2) {
+        printf("BEES15\n");
         if (s_emergencySaveFunction) {
+            printf("BEES16\n");
             s_emergencySaveFunction(sig);
         }
+        printf("BEES17\n");
         if ((s_flags & AutoRestart) && s_autoRestartCommandLine) {
+            printf("BEES18\n");
             QThread::sleep(1);
             startProcess(s_autoRestartCommandLine.argc, const_cast<const char **>(s_autoRestartCommandLine.argv), false);
         }
+        printf("BEES19\n");
         crashRecursionCounter++;
     }
 
+    printf("BEES20\n");
     if (crashRecursionCounter < 3) {
+        printf("BEES21\n");
         // If someone is telling me to stop while I'm already crashing, then I should resume crashing
         signal(SIGTERM, &crashOnSigTerm);
+        printf("BEES22\n");
 
         // NB: all metadata writing ought to happen before closing FDs to reduce synchronization problems with dbus.
 
         // WARNING: do not forget to increase Metadata::argv's size when adding more potential arguments!
         Metadata data(s_drkonqiPath.get());
+        printf("BEES23\n");
 #ifdef Q_OS_LINUX
         // The ini is required to be scoped here, as opposed to the conditional scope, so its lifetime is the same as
         // the regular data instance!
         MetadataINIWriter ini(s_metadataPath);
+        printf("BEES24\n");
         // s_appFilePath can point to nullptr
         // not exactly sure how, maybe some race condition due to KCrashDelaySetHandler ?
         if (!s_appFilePath) {
@@ -599,7 +623,9 @@ void KCrash::defaultCrashHandler(int sig)
 
         fprintf(stderr, "KCrash: Application '%s' crashing... crashRecursionCounter = %d\n", s_appName ? s_appName.get() : "<unknown>", crashRecursionCounter);
 
+        printf("BEES24\n");
         if (s_launchDrKonqi != 1) {
+            printf("BEES25\n");
             setCrashHandler(nullptr);
 #if !defined(Q_OS_WIN)
             raise(sig); // dump core, or whatever is the default action for this signal.
@@ -607,8 +633,10 @@ void KCrash::defaultCrashHandler(int sig)
             return;
         }
 
+        printf("BEES26\n");
 #if !defined(Q_OS_WIN) && !defined(Q_OS_OSX)
         if (!(s_flags & KeepFDs)) {
+            printf("BEES27\n");
             // This tries to prevent problems where applications fail to release resources that drkonqi might need.
             // Specifically this was introduced to ensure that an application that had grabbed the X11 cursor would
             // forcefully have it removed upon crash to ensure it is ungrabbed by the time drkonqi makes an appearance.
@@ -620,12 +648,15 @@ void KCrash::defaultCrashHandler(int sig)
             // be near our tracing/raise().
             closeAllFDs();
+            printf("BEES28\n");
         }
 #if HAVE_X11
         else if (auto display = qGuiApp->nativeInterface<QNativeInterface::QX11Application>()->display()) {
             close(ConnectionNumber(display));
+            printf("BEES29\n");
         }
 #endif
 #endif
+        printf("BEES30\n");
 
 #ifndef NDEBUG
         fprintf(stderr,
@@ -638,21 +669,28 @@ void KCrash::defaultCrashHandler(int sig)
             fprintf(stderr, "%s ", s_autoRestartCommandLine.argv[i]);
         }
         fprintf(stderr, "\n");
+        printf("BEES31\n");
 #endif
 
         startProcess(argc, argv, true);
+        printf("BEES32\n");
     }
+    printf("BEES33\n");
 
     if (crashRecursionCounter < 4) {
+        printf("BEES34\n");
         fprintf(stderr, "Unable to start Dr. Konqi\n");
     }
+    printf("BEES35\n");
 
     if (s_coreConfig.isProcess()) {
+        printf("BEES36\n");
         fprintf(stderr, "Re-raising signal for core dump handling.\n");
         KCrash::setCrashHandler(nullptr);
         raise(sig);
         // not getting here
     }
+    printf("BEES37\n");
 
     _exit(255);
 }
 
